-- -*- mode: lua; encoding: windows-1251 -*-

function attach(sm)
	sm:subscribe({signal = "on_finalize",	fun = this.init})
	sm:subscribe({signal = "on_update",	fun = this.on_update})
end

local signals = {
	net_spawn = {},
	net_destroy = {},
	update = {},
	first_update = {},
	info = {},
	item_take = {},
	item_drop = {},
	key_press = {},
	key_release = {},
	mouse_wheel = {},
	cell_item_select = {},
	cell_item_focus = {},
	cell_item_mouse = {},
	cell_item_focus_lost = {},
	trade_open = {},
	trade_close = {}
}

local always_once = { net_spawn = true, first_update = true }
local unreg_queue = {}
local need_clear = false
---------------------------------------------------------------------------------------------------------------------
function subscribe( name, func, params )
	local tbl = signals[ name ] or abort( "xr_s.subscribe: unknown signal name: %s", name )
	tbl[ func ] = params or {}
	if always_once[ name ] then
		tbl[ func ].once = true
	end
end

function unsubscribe( name, func, queue )
	local tbl = signals[ name ] or abort( "xr_s.unsubscribe: unknown signal name: %s", name )
	if queue then
		table.insert( unreg_queue, { f = func, n = name } )
		need_clear = true
	else
		local t = tbl[ func ]
		if t and t.self then
			t.self = nil
		end
		tbl[ func ] = nil
	end
end
---------------------------------------------------------------------------------------------------------------------
function on_event( name, ... )
	for func, t in pairs( signals[ name ] ) do
		local args = { ... }
		if t.userobj then
			table.insert( args, t.userobj )
		end
		if t.self then
			table.insert( args, 1, t.self )
		end

		func( unpack( args ) )

		if t.once then
			table.insert( unreg_queue, { f = func, n = name } )
			need_clear = true
		end
	end
end
---------------------------------------------------------------------------------------------------------------------
local function update_timeout( d, t )
	if t.timeout == nil then
		return true
	elseif t.updtime == nil then
		t.updtime = t.timeout
		return false
	elseif t.updtime > 0 then
		t.updtime = t.updtime - d
		return false
	else
		t.updtime = t.timeout
		return true
	end
end

function on_update( delta )
	for func, t in pairs( signals.update ) do
		if update_timeout( delta, t ) then
			if t.self then
				func( t.self, delta, t.userobj )
			else
				func( delta, t.userobj )
			end

			if t.once then
				table.insert( unreg_queue, { f = func, n = "update" } )
				need_clear = true
			end
		end
	end

	if need_clear then
		for i, v in ipairs( unreg_queue ) do
			local t = signals[ v.n ][ v.f ]
			if t and t.self then
				t.self = nil
			end
			signals[ v.n ][ v.f ] = nil
		end
		unreg_queue = {}
		need_clear = false
	end
end
---------------------------------------------------------------------------------------------------------------------
local attach_modules = {



}
function init()
	for i, v in ipairs(attach_modules) do
		if _G[ v ] then
			_G[ v ].attach()
		else
			log( "! %s: Error module %s", script_name(), v )
		end
	end
end
