-----------------------------------------------------------------------------------
-- Monster binding
-----------------------------------------------------------------------------------

local addon_actor = db.actor
local strpos = string.find

function bind(obj)
	printf("_bp: monster.bind: name='%s', id='%d'", obj:name(), obj:id())

	-- Для спауна
	--xr_spawner.spawn_client(obj)

	local new_binder = generic_object_binder(obj)
	obj:bind_object(new_binder)
end

------------------------------------------------------------------------------------
class "generic_object_binder" (object_binder)

function generic_object_binder:__init(obj) super(obj)
	self.loaded = false
	self.MutantManager = ogsm_mutants.MutantManager()

	self.am = ogse_signals.get_mgr()
end 

function generic_object_binder:reload(section)
	object_binder.reload(self, section)
end

function generic_object_binder:reinit()
	object_binder.reinit(self)

	-- У торговца нет поддержки перемещения
	if self.object:clsid() ~= clsid.script_trader then
		self.object:set_patrol_extrapolate_callback(generic_object_binder.extrapolate_callback, self)
	end

	db.storage[self.object:id()] = { }

	self.st = db.storage[self.object:id()]

	self.object:set_callback(callback.patrol_path_in_point, self.waypoint_callback, self)
	self.object:set_callback(callback.hit,					self.hit_callback,		self)
	self.object:set_callback(callback.death,				self.death_callback,	self)
----------------------нож для обыска-------------------------------------------------------------------------------------------
	self.object:set_callback(callback.use_object,			self.use_callback,	self)
-----------------------------------------------------------------------------------------------------------------
end

function generic_object_binder:update(delta)
	object_binder.update(self, delta)

--	printf("_bp: generic_object_binder: UPDATE [name='%s' time=%d]",
--		self.object:name(), time_global())

	-- Апдейт торговли
	if self.object:clsid() == clsid.script_trader then
		trade_manager.update(self.object)
	end

	if self.object:alive() then
		if self.object:is_talk_enabled() then
			self.object:set_tip_text("character_use")
		else
			self.object:set_tip_text("")
		end
	else
-------------------нож для обыска--------------------------------------------
	--	self.object:set_tip_text_default()
if this.load_variable("addon_opt_sakbody",1) == 1 and addon_actor ~= nil then
        local disable = true
	if db.actor:active_slot() == 0 then
           local sc = db.actor:item_in_slot(0):section()
              if strpos(sc, "knife") then
              	disable = false
              end   
	end
        if disable then 
           self.object:set_tip_text("addon_sak_kbodyf") 
	else    
           self.object:set_tip_text("addon_sak_kbodyt")
        end
else
	self.object:set_tip_text_default()
end
------------------------------------------------------------------

	end

----------------- Атака псевдособаки из билда 1935 (взято из lost world trops of doom)
local tExcludedWeapons = {
	["bolt"] 		= true,
	["wpn_knife"] 		= true,
	["wpn_binoc"]        	= true
}

if this.load_variable("addon_opt_buildpsdogi",1) == 1 and addon_actor ~= nil then
	if self.object:clsid() == clsid.pseudodog_s then
--		local oTarget = self.object:get_enemy()		-- иногда получал вылит по get_enemy
		local oTarget = self.object:best_enemy()
		if (self.iTimer or 0) < time_global() then
			if oTarget and oTarget:is_actor() and self.object:see(oTarget) then
				local vDirDog = self.object:direction()
				local vDirTarget = oTarget:direction()
				local iDir = (vDirDog.x * vDirTarget.x) + (vDirDog.z * vDirTarget.z)
				
				if Dist("Obj", self.object, oTarget) < 10 and iDir < -0.6 then
					level.add_cam_effector("camera_effects\\build_1935_pseudodog_effect_1.anm", 1994, false, "")
					level.add_cam_effector("camera_effects\\build_1935_pseudodog_effect_2.anm", 1995, false, "")					
					level.add_pp_effector("psy_antenna.ppe", 395, false)		
						
            		local oSnd = sound_object("monsters\\pseudodog\\psy_affect_0")
            		oSnd:play_at_pos(self.object, self.object:position() )
						
					local h = hit()
					h.draftsman = self.object
					h.type = hit.telepatic
					h.direction = vector():set(0, 0, 0)
					h.power = 0.2
					h.impulse = 0.0
					oTarget:hit(h)
					
					local oActiveItem = db.actor:active_item()
					if oActiveItem and not tExcludedWeapons[oActiveItem:section()] then
--------------------------------------------------------------------------------------------------------------
local psy_drop_factor = 0 			-- вераятность что гг не выронит оружие
						-- расчитываем ее исходя из защиты костюма и выносливости
						-- при расчете фактора защиты костюма учтем его состояние
local outfit = db.actor:item_in_slot(6)		-- получаем обьект в 6 слоте (костюм)
local outfit_sect = ""				-- секция костюма
local outfit_cond = 0  				-- состояние костюма
local ltx = system_ini()			-- получаем доступ к файлам
local telepatic_protect = 0			-- коэфицент защиты от пси воздействия (в секции)
local float_telepatic = 0			-- вычисляемый коэфицент защиты от пси воздействия в зависимости от состояния комбеза
local flshp_pr = 0.8				-- какой процент будет использоватся от float_telepatic (80%)
local power = db.actor.power			-- получаем состояние выносливости
local min_power = 0.80				-- состояние выносливости ниже которого будет расти процент выпадания оружия
local setfloatp = 0				-- текущий расчетный процент что гг не выронит оружие исходя из значения выносливости
local setphmin = 0.46				-- процент что гг не выронит оружие при хорошем состоянии выносливости

	  					if outfit ~= nil then
    							outfit_sect = outfit:section()
							outfit_cond = outfit:condition()
							telepatic_protect = ReadLine(ltx, "Number", outfit_sect, "telepatic_protection")
							float_telepatic = ((telepatic_protect/100)*(outfit_cond*100))*flshp_pr
  						else
    							outfit_sect = nil
							outfit_cond = 0
    							telepatic_protect = 0
							float_telepatic = 0
  						end

      						if power < min_power then
							setfloatp = (0.05+(power/100)*90)/1.7
     						else
							setfloatp = setphmin
      						end

						psy_drop_factor = float_telepatic + setfloatp
						--log3("процент защиты "..psy_drop_factor.."")

						--if math.random() > 0.6 then
						if math.random() > psy_drop_factor then
							db.actor:drop_item(oActiveItem)
						end
					end
--------------------------------------------------------------------------------------------------------------
					self.iTimer = time_global() + 4000
				end	
			end
				
		elseif (self.iTimer or 0) < time_global() + 2000 then
			level.remove_cam_effector(1994)
			level.remove_cam_effector(1995)
			level.remove_pp_effector(395)
		end
	end
end
------------------------

	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)
	end
end

------------------нож для обыска------------------------------------------------------------
function generic_object_binder:use_callback(obj, who)
if this.load_variable("addon_opt_sakbody",1) == 1 and addon_actor ~= nil then
	if self.object==nil then return end
	if not self.object:alive() then
		if who:id()==0 then
            local actor = db.actor			
			if actor:active_slot() ~= 0 or 
               ( not strpos(  actor:item_in_slot(0):section(), "knife" ) ) then
				addon_sak_params.set_obj_usable(obj:id(), false)
			else
				addon_sak_params.set_obj_usable(obj:id(), true)
			end
		end
	end
end

self.am:call("monster_obj_use", obj, who)

end
--------------------------------------------------------------------------------
--[[
function generic_object_binder:extrapolate_callback()
	local cur_pt = self.object:get_current_point_index()

    if self.object:get_script ()	== false then 
       return false
    end    
    
	if patrol(self.object:patrol()):flags(cur_pt):get() == 0 then
		--printf("_bp: generic_object_binder: extrapolate_callback: cur_pt = %d: true", cur_pt)
		return true
	end
	--printf("_bp: generic_object_binder: extrapolate_callback: cur_pt = %d: false", cur_pt)
	return false
end
--]]

function generic_object_binder:extrapolate_callback()
	if not self.object:get_script() then return false end
	--
	local cur_pt = self.object:get_current_point_index() 
	local patr = self.object:patrol()
	if patr == "" then
		--log3("!![%s] Invalid patrol path name [%s] for object [%s]", script_name(), patr, self.object:name())
	elseif patrol(patr):flags(cur_pt):get() == 0 then
		return true
	end
	return false
end

function generic_object_binder:waypoint_callback(obj, action_type, index)
	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "waypoint_callback", obj, action_type, index)
	end
end

function generic_object_binder:death_callback(victim, who)
	if who:id() == db.actor:id() then
		xr_statistic.addKillCount(self.object)
	end

	if self.st.mob_death then
		xr_logic.issue_event(self.object, self.st.mob_death, "death_callback", victim, who)
	end

	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", victim, who)
	end

	smart_terrain.on_death( self.object:id() )

	--' Наносим небольшой импульс вперед.
	local h = hit()
	h.draftsman = self.object
	h.type = hit.fire_wound
	h.direction = db.actor:position():sub(self.object:position())
	h:bone("pelvis")
	h.power = 1
	h.impulse = 10
	self.object:hit(h)

	if self.object:name() == "nil" or addon_bb_mod.NpcDeath(victim, who) then
		return false
	end

	self.MutantManager:on_death(self.object)

	if rx_ai then rx_ai.monster_death(victim, who) end
	
	self.am:call("on_monster_dead", victim, who)
end

function generic_object_binder:hit_callback(obj, amount, local_direction, who, bone_index)
--	printf("HIT_CALLBACK: [%s] amount[%s]", obj:name(), amount)
	if self.st.hit then
		xr_logic.issue_event(self.object, self.st.hit, "hit_callback", obj, amount, local_direction, who, bone_index)
	end
end

function generic_object_binder:net_spawn(sobject)
	if not object_binder.net_spawn(self, sobject) then
		return false
	end

	db.add_obj(self.object)

	if rx_ai and not self.object:alive() then
		rx_ai.corpse_net_spawn(self.object,self.loaded)
	end

	xr_gulag.setup_gulag_and_logic_on_spawn( self.object, self.st, sobject, modules.stype_mobile, self.loaded )

	return true
end

function generic_object_binder:net_destroy()
	self.object:set_callback(callback.death,				nil)
	self.object:set_callback(callback.patrol_path_in_point, nil)
	self.object:set_callback(callback.hit,					nil)
---------нож для обыска-----
	self.object:set_callback(callback.use_object,			nil)
----------------------------

	local st = db.storage[self.object:id()]
	if st and st.active_scheme then
		xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy")
	end
	
	db.del_obj(self.object)
	db.storage[self.object:id()] = nil

	object_binder.net_destroy(self)
end 

function generic_object_binder:reload(section)
	object_binder.reload(self, section)
	--printf("generic_object_binder:reload(): self.object:name()='%s'", self.object:name())
end

function generic_object_binder:net_save_relevant()
	--printf("generic_object_binder:net_save_relevant(): self.object:name()='%s'", self.object:name())
	return true
end

function generic_object_binder:save(packet)
	printf("generic_object_binder:save(): self.object:name()='%s'", self.object:name())
	object_binder.save(self, packet)

	xr_logic.save_obj(self.object, packet)
	if self.object:clsid() == clsid.script_trader then
		trade_manager.save(self.object, packet)
	end
end

function generic_object_binder:load(reader)
	self.loaded = true

	printf("generic_object_binder:load(): self.object:name()='%s'", self.object:name())
	object_binder.load(self, reader)

	if reader:r_eof() then
		abort("SAVE FILE IS CORRUPT")
	end

	xr_logic.load_obj(self.object, reader)
	if self.object:clsid() == clsid.script_trader then
		trade_manager.load(self.object, reader)
	end
end

----------------------------------------------------------------
-- функции для сохранения настроек в меню

function load_variable(variable_name, value_if_not_found)
	local vn=compress_name(variable_name)
	if vn then
		return xr_logic.pstor_retrieve(db.actor, vn, value_if_not_found)
	end
end

function compress_name(name)
	return name
end

-----------------------------------------------------------------
