function init    (obj)
	xr_motivator.AddToMotivator(obj)
end

function actor_init    (npc)
	npc:bind_object(actor_binder(npc))
end

local game_difficulty_by_num = {
	[0] = "gd_novice",
	[1] = "gd_stalker",
	[2] = "gd_veteran",
	[3] = "gd_master"
	}

lasthealth  = 0
lasttime	= 0
post_process = 0
local weapon_hide = false
----------------------------------------------------------------------------------------------------------------------
class "actor_binder" (object_binder)
----------------------------------------------------------------------------------------------------------------------
function actor_binder:__init (obj) super(obj)
	self.bCheckStart = false
	self.weather_manager = level_weathers.WeatherManager()
	--self.weather_manager = level_weathers.get_weather_manager()
--	self.actor_detector = xr_detector.actor_detector()
	
	self.am = ogse_signals.get_mgr()
	self.am:call("on_load_before_all")
	self.am:call("on_init", obj)

end

function actor_binder:__finalize()
  self.am:call( "on_finalize" )
	--xr_s.init()
end
----------------------------------------------------------------------------------------------------------------------
local function lc_question_add() --Переход "Припять - ЧАЭС" задаёт вопрос о смене уровня.
	local sobj = alife():object("exit_to_stancia_01")
	if sobj then
		local lc = sobj:get_level_changer()
		if lc.silent_mode ~= 0 then
			lc.silent_mode = 0
			log3( "~~[%s]: fixed ['exit_to_stancia_01']...", script_name() )
		end
	end
end

local function del_buggy_objects() --Удаление из игры глючных объектов
	local names = {
----Рестрикторы постоянных звуков стрельбы в Припяти----
		"pri_ambient_battle_sound_zone_0000",
		"pri_ambient_battle_sound_zone_0001",
		"pri_ambient_battle_sound_zone_0002",
		"pri_ambient_battle_sound_zone_0003",
--------------------------------------------------------
-----Рестрикторы постоянных звуков стрельбы на ЧАЭС-----
		"aes_space_restrictor_sound_battle_0000",
		"aes_space_restrictor_sound_battle_0001",
--------------------------------------------------------
		"sar_enter_zone", --Рестриктор, воспроизводящий "зов Монолита" в Саркофаге
		"mil_physic_object_0127", --глючно заспавненная модель автомата на АС
--------------------------------------------------------
		"rosros_cutscene", --Рестриктор, запускающий облет камеры на ДТ
		"pri_zone_no_gravity", --Аномалия выполнена очень криво, ибо можно подняться и пройти сверху, только с замедлением, как по воде. Такое ощущение, что стоит что-то невидимое, и на него можно залезть и прогуляться. Лучше убрать, выглядит как баг.
	}
	for _, n in ipairs( names ) do
		local sobj = alife():object( n )
		if sobj then
			log3( "~~[%s]: found [%s], removing...", script_name(), sobj:name() )
			alife():release(sobj, true)
		end
	end
end

function actor_binder:net_spawn(data)
------------KD: установка настроек графики------------
	-- шмапы
	cmd("r2_ls_depth_bias -0.00005")
	cmd("r2_ls_depth_scale 1.00001")
	cmd("r2_sun_depth_far_bias -0.00001")
	cmd("r2_sun_depth_far_scale 1.0")
	cmd("r2_sun_depth_near_bias -0.0001")
	cmd("r2_sun_depth_near_scale 1.00004")
	cmd("r2_sun_focus on")
	-- избавляемся от пересвета поверхностей
--	cmd("r2_ls_bloom_threshold 1.") --блум
	cmd("r2_sun_lumscale 1.") --мультипликатор цвета солнца (идиотская настройка)
--	cmd("r2_rain_drops_control on") --капли на стекле
--	cmd("r2_lens_dirt_control on") --грязь на линзе

--addon--
cmd("r2_ls_bloom_fast off")
cmd("r2_ls_bloom_kernel_b 0.7")
cmd("r2_ls_bloom_kernel_g 4.0")
cmd("r2_ls_bloom_kernel_scale 0.7")
cmd("r2_ls_bloom_speed 100.")
cmd("r2_ls_bloom_threshold 0.4")


----------------------KD: end-------------------------

        printf("actor net spawn")

	level.show_indicators()

	self.bCheckStart = true
	self.weapon_hide = false -- спрятано или нет оружие при разговоре.
	weapon_hide = false -- устанавливаем глобальный дефолтовый флаг.

	if object_binder.net_spawn(self,data) == false then
		return false
	end

	db.add_actor(self.object)
	
			if not db.storage[self.object:id()].pstor then	--KRodin: из xr_logic почему-то не срабатывает, поэтому создаём pstor здесь.
				db.storage[self.object:id()].pstor = {}
			end

	if self.st.disable_input_time == nil then
		level.enable_input()
	end

	self.weather_manager:reset()
--	game_stats.initialize ()

	if(actor_stats.add_to_ranking~=nil)then
		actor_stats.add_to_ranking(self.object:id())
	end

	--' Загружаем настройки дропа
	death_manager.init_drop_settings()

	ogsr_memory_control.init()
	
	lc_question_add()
	del_buggy_objects()

	if rx_ai then rx_ai.actor_net_spawn() end
	
	--event("actor_net_spawn"):trigger()	
	event("actor_net_spawn"):trigger({data = data})
	
	self.am:call("on_spawn", data)

-------- пауза при загрузке ---------------
--	ui_main_menu.start()
-------------------------------------------
	ogsm_funcs.on_game_load()
--	if (gps_habar) then gps_habar.on_game_load() end
xr_s.on_event("net_spawn")

	return true
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:net_destroy()
	if(actor_stats.remove_from_ranking~=nil)then
		actor_stats.remove_from_ranking(self.object:id())
	end
	xr_s.on_event("net_destroy")
--	game_stats.shutdown ()
	db.del_actor(self.object)

    sr_light.clean_up ()

	self.object:set_callback(callback.inventory_info, nil)
	self.object:set_callback(callback.article_info, nil)
	self.object:set_callback(callback.on_item_take, nil)
	self.object:set_callback(callback.on_item_drop, nil)
	--self.object:set_callback(callback.actor_sleep, nil)
	self.object:set_callback(callback.task_state, nil)
	self.object:set_callback(callback.level_border_enter, nil)
	self.object:set_callback(callback.level_border_exit, nil)
	self.object:set_callback(callback.take_item_from_box, nil)
	self.object:set_callback(callback.on_ruck, nil)
	self.object:set_callback(callback.on_slot, nil)
	self.object:set_callback(callback.on_key_press, nil)
	self.object:set_callback(callback.on_key_release, nil)
	self.object:set_callback(callback.on_key_hold, nil)
	self.object:set_callback(callback.on_belt, nil)
	self.object:set_callback(callback.death, nil)
	self.object:set_callback(callback.use_object, nil)
	self.object:set_callback(callback.level_changer_action, nil)
	self.object:set_callback(callback.on_mouse_wheel, nil)
	self.object:set_callback(callback.on_cell_item_select, nil)
	self.object:set_callback(callback.on_cell_item_focus, nil)
	self.object:set_callback(callback.on_cell_item_focus_lost, nil)
	self.object:set_callback(callback.on_mouse_move, nil)
	self.object:set_callback(callback.on_cell_item_mouse, nil)
	self.object:set_callback(callback.on_user_command, nil)

	if sr_psy_antenna.psy_antenna then
		sr_psy_antenna.psy_antenna:destroy()
		sr_psy_antenna.psy_antenna = false
	end

	xr_sound.stop_all_sound_object()
	if ui_grenade_marks then
		ui_grenade_marks.remove_grenade_marks()
	end
	object_binder.net_destroy(self)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:reinit()
	object_binder.reinit(self)
	
	local npc_id = self.object:id()

	db.storage[npc_id] = { }

	self.st = db.storage[npc_id]
	self.st.pstor = nil

	self.next_restrictors_update_time = -10000

	self.object:set_callback(callback.inventory_info, self.info_callback, self)
	self.object:set_callback(callback.article_info, self.article_callback, self)
	self.object:set_callback(callback.on_item_take, self.on_item_take, self)
	self.object:set_callback(callback.on_item_drop, self.on_item_drop, self)
	self.object:set_callback(callback.trade_sell_buy_item, self.on_trade, self) -- for game stats
	--self.object:set_callback(callback.actor_sleep, self.sleep_callback, self)
	self.object:set_callback(callback.task_state, self.task_callback, self)
	--self.object:set_callback(callback.map_location_added, self.map_location_added_callback, self)
	self.object:set_callback(callback.level_border_enter, self.level_border_enter, self)
	self.object:set_callback(callback.level_border_exit, self.level_border_exit, self)
	self.object:set_callback(callback.take_item_from_box, self.take_item_from_box, self)
	self.object:set_callback(callback.on_ruck, self.item_to_backpack, self)	-- перемещение предмета в рюкзак
	self.object:set_callback(callback.on_slot, self.item_to_slot, self)		-- перемещение предмета в слот
	self.object:set_callback(callback.on_key_press, self.on_key, self)			-- нажатие клавиши
	self.object:set_callback(callback.on_key_release, self.on_key_free, self)		-- отпускание клавиши
	self.object:set_callback(callback.on_key_hold, self.on_key_hold, self)		-- удержание клавиши
	self.object:set_callback(callback.on_belt, self.on_belt, self)		-- перемещение предмета на пояс
	self.object:set_callback(callback.death, self.actor_death_callback, self)	-- смерть гг
	self.object:set_callback(callback.use_object, self.use_inventory_item, self) -- использование предмета
	self.object:set_callback(callback.level_changer_action, self.level_changer_action, self) -- переход на локацию
    self.object:set_callback( callback.on_mouse_wheel, self.on_wheel_rotation, self ) -- вращение колесика мыши
    self.object:set_callback( callback.on_cell_item_select, self.on_select_item, self ) -- выбор предмета
	self.object:set_callback( callback.on_cell_item_focus, self.on_cell_item_focus, self ) -- наведение курсора на предмет
	self.object:set_callback( callback.on_cell_item_focus_lost, self.on_cell_item_focus_lost, self ) -- убирание курсора с предмета
	self.object:set_callback( callback.on_mouse_move, self.on_mouse_move, self ) -- движение мыши
	self.object:set_callback( callback.on_cell_item_mouse, self.on_cell_item_mouse, self ) 
	self.object:set_callback( callback.on_user_command, self.on_user_command, self ) 
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:take_item_from_box(box, item)
	local story_id = box:story_id()
	if story_id == nil then
		return
	end

	treasure_manager.take_item_from_box(box, story_id)
	
	event("take_item_from_box"):trigger({box = box, item = item})
	if (gps_habar) then gps_habar.on_item_take_from_box(box, item) end
	
--[[	
	local respawner = se_respawn.get_respawner_by_parent(story_id)
	if respawner == nil then
		return
	end
	
	--' Необходимо уменьшить счетчик в респавнере
	respawner:remove_spawned(item:id())

	local smart_terrain = db.strn_by_respawn[respawner:name()]
	if smart_terrain == nil then
		return
	end

	local npc = smart_terrain.gulag:get_nearest_online_obj(db.actor:position())
    if npc ~= nil then
	    xr_sound.set_sound_play(npc, "reac_box")
	    xr_gulag.setGulagEnemy(smart_terrain:name() , db.actor)		
    end
]]
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:level_border_enter(npc, info_id)
--	self.actor_detector:actor_enter()
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:level_border_exit(npc, info_id)
--	self.actor_detector:actor_exit()
end
----------------------------------------------------------------------------------------------------------------------
local info2call = {
  ui_trade                 = "on_trade_open",
  ui_trade_hide            = "on_trade_hide"
}

function actor_binder:info_callback(npc, info_id)
	printf("*INFO*: npc='%s' id='%s'", npc:name(), info_id)
	--' Сюжет
	level_tasks.proceed(self.object)
	-- Отметки на карте
	level_tasks.process_info_portion(info_id)
	
	xr_s.on_event("info", info_id)
	
	self.am:call( "on_info", npc, info_id )
    local sc = info2call[ info_id ]
	if sc then
		self.am:call( sc, npc )
	end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_trade (item, sell_bye, money)
    if sell_bye == true then
       game_stats.money_trade_update (money)
    else       
       game_stats.money_trade_update (-money) 
    end   
	
	event("on_trade"):trigger({item = item, sell_bye = sell_bye, money = money})
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:article_callback(npc, group, name)
	--printf("article_callback [%s][%s]", group, name)
	if device().precache_frame >1 then return end
	
--	if group == "Diary" then
--		news_manager.send_encyclopedy("diary", group)
--	else
--		news_manager.send_encyclopedy("encyclopedy", group)
--	end

	if group == "Diary" then
		news_manager.send_encyclopedy("diary", group)
		amk_utils.send_tip(game.translate_string(name), "Заметка в журнале:", nil, 7)
	elseif group == "Mutants" then
		news_manager.send_encyclopedy("encyclopedy", group)
		amk_utils.send_tip(game.translate_string(name), "Заметка о мутантах:", nil, 7)
	elseif group == "Social" then
		news_manager.send_encyclopedy("encyclopedy", group)
		amk_utils.send_tip(game.translate_string(name), "Информация о группировке:", nil, 7)
	elseif group == "Artifacts" then
		news_manager.send_encyclopedy("encyclopedy", group)
		amk_utils.send_tip(game.translate_string(name), "Заметка об артефактах:", nil, 7)
	elseif group == "Anomalies" then
		news_manager.send_encyclopedy("encyclopedy", group)
		amk_utils.send_tip(game.translate_string(name), "Заметка об аномалиях:", nil, 7)
	elseif group == "Locations" then
		news_manager.send_encyclopedy("encyclopedy", group)
		amk_utils.send_tip(game.translate_string(name), "Информация о локации:", nil, 7)
	elseif group == "Zone-story" then
		news_manager.send_encyclopedy("encyclopedy", group)
		amk_utils.send_tip(game.translate_string(name), "История Зоны:", nil, 7)
	elseif group == "Stories" then
		news_manager.send_encyclopedy("encyclopedy", group)
		amk_utils.send_tip(game.translate_string(name), "Местный фольклор:", nil, 7)
	elseif group == "memuars" then
		news_manager.send_encyclopedy("encyclopedy", group)
		amk_utils.send_tip(game.translate_string(name), "Личная заметка:", nil, 7)
	elseif group == "Found_PDA" then
		news_manager.send_encyclopedy("encyclopedy", group)
		amk_utils.send_tip(game.translate_string(name), "Скачаны данные:", nil, 7)
	elseif group == "st_operation_agroprom" or group == "LabX18_information" or group == "aes_military_task" then
		news_manager.send_encyclopedy("encyclopedy", group)
		amk_utils.send_tip(game.translate_string(name), "Заметка в журнале:", nil, 7)
	end	

end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_item_take (obj)
	
    level_tasks.proceed(self.object)
    --game_stats.update_take_item (obj, self.object)
--addon_nv.checknv()
if (gps_habar) then gps_habar.on_item_take(obj) end

if rx_ai then rx_ai.actor_item_take(obj) end
xr_s.on_event("item_take", obj)
    event("actor_item_take"):trigger({obj = obj})
	self.am:call("on_take", obj, sobj)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_item_drop (obj)
    level_tasks.proceed(self.object)
    --game_stats.update_drop_item (obj, self.object)
--addon_nv.checknv()
if (gps_habar) then gps_habar.on_item_drop(obj) end
xr_s.on_event("item_drop", obj)
	event("actor_item_drop"):trigger({obj = obj})
	self.am:call("on_drop", obj, sobj)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:item_to_backpack(obj)
	if not obj then return end
	local sobj = alife():object(obj:id())
	if not sobj then return end

--	log3("переместили в рюкзак")
--addon_nv.checknv()

	event("actor_item_toruck"):trigger({obj = obj})	
	self.am:call("on_item_to_ruck", obj, sobj)	
end

----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_belt(obj)
	event("actor_item_tobelt"):trigger({obj = obj})	
	self.am:call("on_item_to_belt", obj, sobj)	
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_key(key, bind)
--log3("нажатие клавиши")
xr_s.on_event( "key_press", key, bind )
		event("actor_on_key"):trigger({key = key, bind = bind})
		self.am:call("on_key_down", key, bind)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_wheel_rotation( vol )
	xr_s.on_event("mouse_wheel", vol)
  self.am:call( "on_wheel", vol )
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_select_item( obj )
local sim = alife()
    xr_s.on_event("cell_item_select", obj, sobj)
  local sobj = sim:object( obj:id() )
  if sobj then
    self.am:call( "on_select_item", obj, sobj )
  end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_cell_item_focus( obj )
	xr_s.on_event("cell_item_focus", obj)
  self.am:call( "on_cell_item_focus", obj )
end

function actor_binder:on_cell_item_focus_lost( obj )
--log3("focus lost")
	xr_s.on_event("cell_item_focus_lost", obj)
  self.am:call( "on_cell_item_focus_lost", obj )
end

function actor_binder:on_cell_item_mouse( obj, x, y, action )
  xr_s.on_event("cell_item_mouse", obj, x, y, action)
  self.am:call( "on_cell_item_mouse", obj, x, y, action )
end
----------------------------------------------
function actor_binder:on_user_command(cmd)
local cmd_lengh = string.len(cmd)			-- получить длинну полученной команды
local com_space = string.find(cmd, " ")		-- поиск пробела в этой команде, получить его индекс
local command, com_value					-- переменные для хранения команды и ее значения

--log3("~ on_user_command: ["..cmd.."] lengh: ["..cmd_lengh.."]")
  if (cmd_lengh >= 1) then												-- если в команде есть хоть 1 символ
    if (com_space ~= nil) then 											-- если пробел нашелся
	  command = string.sub(cmd, 1, (com_space - 1))						-- выдергиваем название введенной команды
	  local com_value_end = string.find(cmd, " ", (com_space + 1))		-- получаем окончание значения. (для этого ищим пробел, начиная с позиции первого найденного пробела)
	  if (com_value_end == nil) then com_value_end = cmd_lengh end		-- если 2й пробел не нашелся, значит окончанием значения будет конец строки полученной команды
	  com_value = string.sub(cmd, (com_space + 1), com_value_end)		-- выдергиваем содержание значения, введенной команды
      command = string.gsub(command, " ", "")							-- удалить пробелы оставшиеся в названии введенной команды
	  com_value = string.gsub(com_value, " ", "")						-- удалить пробелы оставшиеся в значении введенной команды
	  --log3("~ on_user_command: command: ["..command.."], type: "..type(command))
	  --log3("~ on_user_command: value: ["..com_value.."], type: "..type(com_value))
    else																-- если пробел НЕ нашелся
	  command = cmd														-- значит введенное это просто команда без значения
      com_value = "null"												-- значения нет, это затычка
    end
  ------------------------------------------------
  -- изначально command и com_value в формате string это нужно учитывать
  self.am:call("on_console_command", command, com_value)
  end
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_key_free(key, bind)
	xr_s.on_event("key_release", key, bind)
	event("actor_on_key_free"):trigger({key = key, bind = bind})
	self.am:call("on_key_up", key, bind)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_key_hold(key, bind)
	event("actor_on_key_hold"):trigger({key = key, bind = bind})
	self.am:call("on_key_hold", key, bind)
end
---------------------------------------------------------------------------------------------------------------------
function actor_binder:on_mouse_move( velx, vely )
--log3("движение мыши")
  self.am:call( "on_mouse_move", velx, vely )
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:item_to_slot(obj)
	if not obj then return end
	local sobj = alife():object(obj:id())
	if not sobj then return end

--addon_nv.checknv()

	event("actor_item_toslot"):trigger({obj = obj})
	self.am:call("on_item_to_slot", obj, sobj)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:actor_death_callback(victim, who)
	event("on_actor_death"):trigger({victim = victim, who = who})
	self.am:call("on_actor_death_sm", victim, who)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:use_inventory_item(obj)
	if not obj then return end
	local sobj = alife():object(obj:id())
	if not sobj then return end

	event("use_item"):trigger({obj = obj})
end

function actor_binder:task_callback(_task, _objective, _state)
	task_manager.task_callback(_task:get_id(), _objective:get_idx(), _state)
	if _objective:get_idx() == 0 then
		if _state == task.fail then
			news_manager.send_task(db.actor, "fail", _task, _objective)
		elseif _state == task.completed then
			task_manager.reward_by_task(_task)
			news_manager.send_task(db.actor, "complete", _task, _objective)
		else
			news_manager.send_task(db.actor, "new", _task, _objective)
		end
	else
		if _task:get_objective(0):get_state() == task.in_progress then
			news_manager.send_task(db.actor, "update", _task, _objective)
		end
	end
end

----------------------------------------------------------------------------------------------------------------------
function actor_binder:map_location_added_callback(spot_type_str, object_id)
	if (false==app_ready()) or (device().precache_frame>1) then return end
	--'news_manager.send_task(db.actor, "new")
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:level_changer_action( obj, wnd )
  self.am:call( "lc_action", obj, wnd )
end
----------------------------------------------------------------------------------------------------------------------
local update_was_never_called = true

function actor_binder:update(delta)
	object_binder.update(self, delta)

	-- DEBUG slowdown
--	slowdown.update()

	local time = time_global()
	
	game_stats.update (delta, self.object)

	-- апдейт погоды
	self.weather_manager:update()
	
	-- апдейт схемы детектора
--	self.actor_detector:update()

	-- апдейт звуковой схемы актера
	xr_sound.update_actor()
	
	--' Проверка потери жизни
--[[
	if self.object.health - lasthealth > 0.001 or
	   self.object.health - lasthealth < -0.001 then
		printf("%f | %f", self.object.health, self.object.health - lasthealth, game.time() - lasttime)
		lasthealth = self.object.health
		lasttime = game.time()
	end
]]	
	-- Обновление отключения ввода с клавиатуры.
	if self.st.disable_input_time ~= nil and
	   game.get_game_time():diffSec(self.st.disable_input_time) >= self.st.disable_input_idle 
	then
		level.enable_input()
		self.st.disable_input_time = nil
	end
	-- Обновление сна с переносом чувака в указанную позицию
	if self.st.sleep_relocate_time ~= nil and
	   game.get_game_time():diffSec(self.st.sleep_relocate_time) >= self.st.sleep_relocate_idle 
	then
		self.object:set_actor_position(self.st.sleep_relocate_point)
		local dir = self.st.sleep_relocate_point:sub(self.st.sleep_relocate_look)
		self.object:set_actor_direction(dir:getH())
		self.st.sleep_relocate_time = nil
	end

	-- Апдейт прятание оружия игрока во время диалога
	if weapon_hide == true or self.object:is_talking() then
		if self.weapon_hide == false then
			self.object:hide_weapon()
			self.weapon_hide = true
		end
	else
		if self.weapon_hide == true then
			self.object:restore_weapon()
			self.weapon_hide = false
		end
	end	

	-- обновление рестрикторов, которые под логикой, срабатывает через интервалы времени
	if self.next_restrictors_update_time < time then
		bind_restrictor.actor_update(delta)

		self.next_restrictors_update_time = time + 200

		task_manager.actor_update()
	end

	-- обновление постпроцессов
	if post_process ~= 0 then
		if post_process:update () == true then
		   post_process = 0
		end
	end

	-- обновление пси-антенны
	if sr_psy_antenna.psy_antenna then
		sr_psy_antenna.psy_antenna:update(delta)
	end

	--' Вывод сообщения о большой радиации
	if self.object.radiation >= 0.7 then
		local hud = get_hud()
		local custom_static = hud:GetCustomStatic("cs_radiation_danger")
		if custom_static == nil then
			hud:AddCustomStatic("cs_radiation_danger", true)
			hud:GetCustomStatic("cs_radiation_danger"):wnd():SetTextST("st_radiation_danger")
		end
	else
		local hud = get_hud()
		local custom_static = hud:GetCustomStatic("cs_radiation_danger")
		if custom_static ~= nil then
			hud:RemoveCustomStatic("cs_radiation_danger")
		end
	end



 	if self.bCheckStart then
		printf("SET DEFAULT INFOS")		

		if not has_alife_info("storyline_actor_start") and
		   (level.name() == "l01_escape")
		then
			self.object:give_info_portion("storyline_actor_start")
			_G.g_start_avi = true
			printf("*AVI* RUN START AVI")			
		end

--		if not has_alife_info("encyclopedy") then
--			self.object:give_info_portion("encyclopedy")
--		end

		if not has_alife_info("global_dialogs") then
			self.object:give_info_portion("global_dialogs")
		end

		if not has_alife_info("level_changer_icons") then
			self.object:give_info_portion("level_changer_icons")
		end

		level_tasks.add_lchanger_location()

		self.bCheckStart = false		
	end		
	
	if update_was_never_called then 
		self.am:call("on_first_update") 	-- вызывается 1 раз после загрузки
		event("e_first_update"):trigger()
		update_was_never_called = false
	end
	
--	addon_rx_shoot_effect.shoot_effect()
--	addon_xr_mask.dynamic_hud()

	lwc_timer.Update()
	ogsm_funcs.on_actor_update()
--	if (gps_habar) then gps_habar.on_actor_update(delta) end

	if rx_ai then rx_ai.actor_update() end
	--xr_s.on_update( delta )
	self.am:call("on_update", delta)
	event("actor_update"):trigger({delta = delta})
	
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:save(packet)
	
	if rx_ai then rx_ai.actor_save(packet) end
	
	local save_treasure_manager = true
	
	printf("actor_binder:save(): self.object:name()='%s'", self.object:name())
	object_binder.save(self, packet)

	--' Сохраняем уровень сложности
	if save_treasure_manager == true then
		packet:w_u8(level.get_game_difficulty() + 128)
	else
		packet:w_u8(level.get_game_difficulty())
	end


	--' Сохраняем данные об отключенном вводе
	if self.st.disable_input_time == nil then
		packet:w_bool(false)
	else
		packer:w_bool(true)
		utils.w_CTime(packet, self.st.disable_input_time)
	end

	xr_logic.pstor_save_all(self.object, packet)
	self.weather_manager:save(packet)

	sr_psy_antenna.save( packet )
	
	if save_treasure_manager == true then
		treasure_manager.save(packet)      
	end                                  

	task_manager.save(packet)
	lwc_timer.Save(packet)
--	self.actor_detector:save(packet)
	
	event("actor_save"):trigger({packet = packet})
	self.am:call("on_save", packet)
	self.am:call("on_save_after_all")
	
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:load(reader)
	printf("actor_binder:load(): self.object:name()='%s'", self.object:name())
	object_binder.load(self, reader)
	printf("actor_binder:object_binder.load(): self.object:name()='%s'", self.object:name())

	--' Загружаем уровень сложности
	local game_difficulty = reader:r_u8()
	
	local load_treasure_manager = false      
	if game_difficulty >= 128 then           
		game_difficulty = game_difficulty - 128
		load_treasure_manager = true           
	end                                      

	
	get_console():execute("g_game_difficulty "..game_difficulty_by_num[game_difficulty])

	if reader:r_eof() then
		abort("SAVE FILE IS CORRUPT")
	end

	local stored_input_time = reader:r_u8()
	if stored_input_time == true then
		self.st.disable_input_time = utils.r_CTime(reader)
	end

	xr_logic.pstor_load_all(self.object, reader)
	self.weather_manager:load(reader)

	sr_psy_antenna.load(reader)
	
	if load_treasure_manager == true then
		treasure_manager.load(reader)      
	end                                  

	
	task_manager.load(reader)
	lwc_timer.Load(reader)
--	self.actor_detector:load(reader)	
	
	event("actor_load"):trigger({reader = reader})
end
----------------------------------------------------------------------------------------------------------------------

--старт префетча звуков
--if string.find(command_line(), "-noprefetch") == nil then
--	sound_prefetch.prefetch_sounds()
--end


-- Weapon functions
function hide_weapon()
	weapon_hide = true
end
function restore_weapon()
	weapon_hide = false
end

// this is test for section iteration
/**
local function test_section_iteration(file_name, section_name)
	printf			("file    : %s",file_name)
	printf			("section : %s",section_name)

	local			file = ini_file(file_name)
	local			n = file:line_count(section_name)
	printf			("lines   : %d",n)

	local			id, value = "", "", result
	for i=0,n-1 do
		result, id, value	= file:r_line(section_name,i,"","")
		printf		("line %d : %s = %s",i,id,value)
	end
end

test_section_iteration("system.ltx","space_restrictor")
/**/